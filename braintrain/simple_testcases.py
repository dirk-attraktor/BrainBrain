import random
import abc
import copy
import itertools
import random
import string
import json
import bson
import struct
import operator
import sys


ops = [
    [ operator.abs      , 1 , [ [ -2**32 , 2**32] ]],
    [ operator.add      , 2 , [ [ -2**32 , 2**32] , [ -2**32 , 2**32] ]],
    [ operator.sub      , 2 , [ [ -2**32 , 2**32] , [ -2**32 , 2**32] ]],
    [ operator.floordiv , 2 , [ [ -2**32 , 2**32] , [ -2**32 , 2**32] ]],
    [ operator.index    , 1 , [ [ -2**32 , 2**32] ]],
    [ operator.invert   , 1 , [ [ -2**32 , 2**32] ]],
    [ operator.lshift   , 2 , [ [ -2**32 , 2**32] , [ 1     ,     15] ]],
    [ operator.rshift   , 2 , [ [ -2**32 , 2**32] , [ 1     ,     15] ]],
    [ operator.mod      , 2 , [ [ -2**32 , 2**32] , [ -2**32 , 2**32] ]],
    [ operator.or_      , 2 , [ [ -2**32 , 2**32] , [ -2**32 , 2**32] ]],
    [ operator.and_     , 2 , [ [ -2**32 , 2**32] , [ -2**32 , 2**32] ]],
    [ operator.xor      , 2 , [ [ -2**32 , 2**32] , [ -2**32 , 2**32] ]],
    [ operator.pos      , 1 , [ [ -2**32 , 2**32] ]],
    #[ operator.pow     , 2 , [ [ -2**7 ,  2**7 ] , [ -2**3 , 2**3] ]],
    #[ operator.truediv , 2 , [ [ -2**32 , 2**32] , [ -2**32 , 2**32] ]],        
]

types = [ 
    ["signed int"     , 'i', [ -2**31 , 2**31-1],0xffffffff], 
    ["unsigned int"   , 'I', [      0 , 2**32-1],0xffffffff], 
    
    ["signed short"   , 'h', [ -2**15 , 2**15-1],    0xffff], 
    ["unsigned short" , 'H', [      0 , 2**16-1],    0xffff], 

    ["signed char"    , 'b', [ -2**7  , 2**7-1 ],      0xff], 
    ["unsigned char"  , 'B', [     0  , 2**8-1 ],      0xff], 
]
ends = [
    ["little-endian" , "<"],
    ["big-endian"    , ">"],
]

def autogenerated_tasks():
    for op,nr_of_inputs, limits in ops:
        for inputtype in types:
            for outputtype in types:
                for inputbyteorder in ends:
                    for outputbyteorder in ends:
                        opname = ("%s"%op).split(" ")[2].replace(">","")
                        name = "GenTest '%s' %s %s'%s' return %s'%s' " % (opname, nr_of_inputs, inputbyteorder[1], inputtype[0],  outputbyteorder[1], outputtype[0]  )
                        def func1(op, nr_of_inputs, limits, inputtype, outputtype, inputbyteorder,  outputbyteorder):
                            op = op
                            nr_of_inputs = nr_of_inputs
                            limits = limits
                            inputtype = inputtype
                            outputtype = outputtype
                            inputbyteorder =  inputbyteorder
                            outputbyteorder = outputbyteorder
                            def func():
                                while True:
                                    if nr_of_inputs == 1:
                                        p1_min = max([inputtype[2][0], limits[0][0]])
                                        p1_max = min([inputtype[2][1], limits[0][1]])
                                        input1 =  random.randint(p1_min, p1_max)
                                        r = op( input1 ) & outputtype[3]
                                        if outputtype[0].find("unsigned") == -1: # is signed
                                            if r >= (outputtype[3] + 1)/2:
                                                r = (outputtype[3] + 1 - r) * -1
                                        d = [  struct.pack(inputbyteorder[1] + inputtype[1],input1)  , struct.pack(outputbyteorder[1] + outputtype[1],r) ]
                                    elif nr_of_inputs == 2:
                                        p1_min = max([inputtype[2][0], limits[0][0]])
                                        p1_max = min([inputtype[2][1], limits[0][1]])
                                        p2_min = max([inputtype[2][0], limits[1][0]])
                                        p2_max = min([inputtype[2][1], limits[1][1]])
                                        input1 = random.randint(p1_min, p1_max) 
                                        input2 = random.randint(p2_min, p2_max)
                                        try:
                                            r = op( input1 , input2) & outputtype[3]
                                        except:
                                            continue
                                        if outputtype[0].find("unsigned") == -1: # is signed
                                            if r >= (outputtype[3] + 1)/2:
                                                r = (outputtype[3] + 1 - r) * -1
                                        d = [  struct.pack(inputbyteorder[1] + inputtype[1]+inputtype[1], input1, input2)  , struct.pack(outputbyteorder[1] + outputtype[1], r) ]
                                    yield d
                            return func
                        yield [name, func1(op, nr_of_inputs, limits, inputtype, outputtype, inputbyteorder,  outputbyteorder)]

def get_examplesource(taskname):
    max_cachesize = 4000
    cache_hitrate = 0.999
    examplecache = {}
    
    def f():
        task = task_mapping[taskname]
        while True:
            iogenerator = iter(task())
            while True:
                random_index = random.randint(0,max_cachesize)
                if random.random() < cache_hitrate:
                    try:
                        r = examplecache[random_index]
                        yield r
                        continue
                    except:
                        pass
                i, o = next(iogenerator)
                r = [bytes(i),bytes(o)]
                examplecache[random_index] = r
                yield r 
    return f
   
def examplesource_add_2_packed_uint():
    while True:
        a = random.randint(0, 2*1000*1000*1000)
        b = random.randint(0, 2*1000*1000*1000)
        c = a + b
        src = struct.pack('II', a , b)
        dst = struct.pack('I', c)
        yield [src, dst]

def examplesource_add_2_packed_int():
    while True:
        a = random.randint(-1*1000*1000*1000, 1*1000*1000*1000)
        b = random.randint(-1*1000*1000*1000, 1*1000*1000*1000)
        c = a + b
        src = struct.pack('ii', a , b)
        dst = struct.pack('i', c)
        yield [src, dst]        
        
def examplesource_decimal2byte():
    while True:
        a = random.randint(0, 255)
        yield [bytes("%s" % a,"ASCII"), bytes([a]) ]
        
def examplesource_byte2decimal():
    while True:
        a = random.randint(0, 255)
        yield [bytes([a]) , bytes("%s" % a,"ASCII")]
         
def examplesource_add_2_bytes():
    while True:
        a = random.randint(0, 127)
        b = random.randint(0, 127)
        c = a + b
        yield [bytes([a,b]) , bytes([c])]
        
def examplesource_add_3_bytes():
    while True:
        a = random.randint(0, 80)
        b = random.randint(0, 80)
        c = random.randint(0, 80)
        d = a + b  + c 
        yield [bytes([a,b,c]) , bytes([d])]
        
def examplesource_sub_2_bytes():
    while True:
        a = random.randint(128, 255)
        b = random.randint(0, 128)
        c = a - b
        yield [bytes([a,b]) , bytes([c])]
  
def examplesource_add_3_integer_bson():
    while True:
        a = random.randint(0, 1000000000)
        b = random.randint(0, 1000000000)
        c = random.randint(0, 1000000000)
        d = a + b + c 
        yield [bson.dumps({0:a, 1:b, 2:c}) , bson.dumps({0:d})]
    
  
def examplesource_add_2_integer_bson():
    while True:
        a = random.randint(0, 2000000000)
        b = random.randint(0, 2000000000)
        c = a + b
        yield [bson.dumps({0:a,1:b}) , bson.dumps({0:c})]
    
def examplesource_sub_2_integer_bson():
    while True:
        a = random.randint(0, 2000000000)
        b = random.randint(0, 2000000000)
        c = a - b
        yield [bson.dumps({0:a,1:b}) , bson.dumps({0:c})]
      
    
def examplesource_add_2_integer():
    while True:
        a = random.randint(0, 2000000000)
        b = random.randint(0, 2000000000)
        c = a + b
        yield [bytes("%s\t%s" % (a, b),"ASCII") , bytes("%s" % c,"ASCII")]
    
def examplesource_sub_2_integer():
    while True:
        a = random.randint(0, 2000000000)
        b = random.randint(0, 2000000000)
        c = a - b
        yield [bytes("%s\t%s" % (a, b),"ASCII") , bytes("%s" % c,"ASCII")]
    
    
def examplesource_add_2_float():
    while True:
        a = random.random() * random.randint(0, 2000000000)
        b = random.random() * random.randint(0, 2000000000)
        c = a + b
        yield [bytes("%s\t%s" % (a, b),"ASCII") , bytes("%s" % c,"ASCII")]
    
def examplesource_sub_2_float():
    while True:
        a = random.random() * random.randint(0, 2000000000)
        b = random.random() * random.randint(0, 2000000000)
        c = a - b
        yield [bytes("%s\t%s" % (a, b),"ASCII") , bytes("%s" % c,"ASCII")]
      
def split_string_on_delimiter():
    while True:
        s = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randint(3,200)))
        delimiter = random.choice(s)
        output = s.split(delimiter)
        yield  [ bytes(json.dumps([delimiter, s ]),"ASCII") ,  bytes(json.dumps(output),"ASCII") ] 

def secret_string_1():
    while True:
        yield  [ bytes('',"ASCII") ,  bytes("hello world","ASCII") ] 
        
def secret_string_2():
    while True:
        yield  [ bytes('',"ASCII") ,  bytes("hello world ab76vfdaas456s","ASCII") ] 
          
       
task_mapping =  {
    "my-testcase decimal2bytes": examplesource_decimal2byte,
    "my-testcase byte2decimal": examplesource_byte2decimal,
    
    "my-testcase find secret string 1": secret_string_1,
    "my-testcase find secret string 2": secret_string_2,
    
    "my-testcase add 3 bytes": examplesource_add_3_bytes,
    
    "my-testcase add 2 bytes": examplesource_add_2_bytes,
    "my-testcase sub 2 bytes": examplesource_sub_2_bytes,
    
    "my-testcase add 2 packed uint": examplesource_add_2_packed_uint,
    "my-testcase add 2 packed int":  examplesource_add_2_packed_int,
    
    "my-testcase add 2 integer bson": examplesource_add_2_integer_bson,
    "my-testcase sub 2 integer bson": examplesource_sub_2_integer_bson,
    
    "my-testcase add 3 integer bson": examplesource_add_3_integer_bson,
    
    "my-testcase add 2 integer": examplesource_add_2_integer,
    "my-testcase sub 2 integer": examplesource_sub_2_integer,
    
    "my-testcase add 2 float": examplesource_add_2_float,
    "my-testcase sub 2 float": examplesource_sub_2_float,
    
    "my-testcase split_string_on_delimiter": split_string_on_delimiter,
}

for autotask_name, autotask_func in  autogenerated_tasks():
    #print(autotask_name, autotask_func)
    task_mapping[autotask_name] = autotask_func
    
    
#print(len(task_mapping))
    